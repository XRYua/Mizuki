---
import { Icon } from "astro-icon/components";
import { readdir } from "node:fs/promises";
import path from "node:path";
import { siteConfig } from "../../config";
import I18nKey from "../../i18n/i18nKey";
import { i18n } from "../../i18n/translation";
import {
	getCategoryList,
	getSortedPosts,
	getTagList,
} from "../../utils/content-utils";
import { getPostUrl } from "../../utils/url-utils";
import WidgetLayout from "./WidgetLayout.astro";

interface Props {
	class?: string;
	style?: string;
}

const { class: className, style } = Astro.props;

const siteStartDate = siteConfig.siteStartDate || "2025-01-01";
const posts = await getSortedPosts();
const categories = await getCategoryList();
const tags = await getTagList();

let totalWords = 0;
for (const post of posts) {
	if (post.body) {
		let text = post.body;
		text = text.replace(/```[\s\S]*?```/g, "");
		text = text.replace(/`[^`]+`/g, "");
		const cjkPattern =
			/[\u4e00-\u9fa5\u3040-\u309f\u30a0-\u30ff\uac00-\ud7af\u3000-\u303f\uff00-\uffef]/g;
		const cjkMatches = text.match(cjkPattern);
		const cjkCount = cjkMatches ? cjkMatches.length : 0;
		const nonCjkText = text.replace(cjkPattern, " ");
		const nonCjkWords = nonCjkText
			.split(/\s+/)
			.filter((word) => word.trim().length > 0);
		totalWords += cjkCount + nonCjkWords.length;
	}
}

function formatNumber(num: number): string {
	return num.toLocaleString();
}

const latestPost = posts.reduce((latest, post) => {
	if (!latest) return post;
	return post.data.published > latest.data.published ? post : latest;
}, posts[0]);

const postsWithUpdated = posts.filter((post) => post.data.updated);
const latestEditedPost = postsWithUpdated.reduce(
	(latest, post) => {
		if (!latest) return post;
		return post.data.updated! > latest.data.updated! ? post : latest;
	},
	postsWithUpdated[0],
);

const postsBaseDir = path.resolve("src/content/posts");

async function getMarkdownFiles(dir: string): Promise<string[]> {
	const entries = await readdir(dir, { withFileTypes: true });
	const files = await Promise.all(
		entries.map(async (entry) => {
			const fullPath = path.join(dir, entry.name);
			if (entry.isDirectory()) return getMarkdownFiles(fullPath);
			if (entry.isFile() && fullPath.endsWith(".md")) return [fullPath];
			return [];
		}),
	);
	return files.flat();
}

const markdownFiles = await getMarkdownFiles(postsBaseDir);
let latestChangedPost: (typeof posts)[number] | null = null;
for (const file of markdownFiles) {
	const relativePath = path.relative(postsBaseDir, file).replace(/\\/g, "/");
	const postId = relativePath.replace(/\.md$/, "");
	const post = posts.find((item) => item.id === postId);
	if (post && (!latestChangedPost || post.data.published > latestChangedPost.data.published)) {
		latestChangedPost = post;
	}
}

function parseRepoFromUrl(repoUrl: string): string | null {
	const cleanUrl = repoUrl.replace(/\.git$/, "").trim();
	const match = cleanUrl.match(/github\.com[:/]([^/]+)\/([^/]+)/i);
	if (!match) return null;
	return `${match[1]}/${match[2]}`;
}

const githubRepo =
	parseRepoFromUrl(process.env.CONTENT_REPO_URL || "") ||
	parseRepoFromUrl(process.env.GITHUB_SERVER_URL && process.env.GITHUB_REPOSITORY
		? `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}`
		: "") ||
	"matsuzaka-yuki/Mizuki";

async function getGithubLastEditDate(paths: string[]): Promise<string | null> {
	for (const repoPath of paths) {
		try {
			const endpoint = `https://api.github.com/repos/${githubRepo}/commits?path=${encodeURIComponent(repoPath)}&per_page=1`;
			const response = await fetch(endpoint, {
				headers: {
					Accept: "application/vnd.github+json",
					"User-Agent": "Mizuki-SiteStats",
				},
			});
			if (!response.ok) continue;
			const data = await response.json();
			const date = data?.[0]?.commit?.committer?.date;
			if (date) return date;
		} catch {
			continue;
		}
	}
	return null;
}

function postPathCandidates(postId: string | undefined) {
	if (!postId) return [];
	return [
		`src/content/posts/${postId}.md`,
		`content/posts/${postId}.md`,
		`posts/${postId}.md`,
	];
}

const lastEditedDate =
	(await getGithubLastEditDate(postPathCandidates(latestEditedPost?.id))) ||
	(latestEditedPost?.data.updated?.toISOString() || null);

const lastPostDate =
	(await getGithubLastEditDate(postPathCandidates(latestPost?.id))) ||
	(latestPost?.data.published?.toISOString() || null);

const blogLastChangeDate =
	(await getGithubLastEditDate(["src/content/posts", "content/posts", "posts"])) ||
	(lastEditedDate || lastPostDate);

const candidateDates = [lastEditedDate, lastPostDate, blogLastChangeDate]
	.filter(Boolean)
	.map((date) => new Date(date!));

const lastActivityDate =
	candidateDates.length > 0
		? new Date(Math.max(...candidateDates.map((d) => d.getTime()))).toISOString()
		: null;

const activityItems = [
	{
		label: "最后编辑文章",
		title: latestEditedPost?.data.title || "-",
		url: latestEditedPost ? getPostUrl(latestEditedPost) : null,
		date: lastEditedDate,
	},
	{
		label: "最后发表文章",
		title: latestPost?.data.title || "-",
		url: latestPost ? getPostUrl(latestPost) : null,
		date: lastPostDate,
	},
	{
		label: "博客最后改动内容",
		title: latestChangedPost?.data.title || "-",
		url: latestChangedPost ? getPostUrl(latestChangedPost) : null,
		date: blogLastChangeDate,
	},
];

const stats = [
	{
		icon: "material-symbols:article-outline",
		label: i18n(I18nKey.siteStatsPostCount),
		value: posts.length,
	},
	{
		icon: "material-symbols:folder-outline",
		label: i18n(I18nKey.siteStatsCategoryCount),
		value: categories.length,
	},
	{
		icon: "material-symbols:label-outline",
		label: i18n(I18nKey.siteStatsTagCount),
		value: tags.length,
	},
	{
		icon: "material-symbols:text-ad-outline-rounded",
		label: i18n(I18nKey.siteStatsTotalWords),
		value: totalWords,
		formatted: true,
	},
	{
		icon: "material-symbols:calendar-clock-outline",
		label: i18n(I18nKey.siteStatsRunningDays),
		value: 0,
		suffix: i18n(I18nKey.siteStatsDays).replace("{days}", ""),
		id: "running-days",
	},
	{
		icon: "material-symbols:ecg-heart-outline",
		label: i18n(I18nKey.siteStatsLastUpdate),
		value: 0,
		id: "last-update",
	},
];
---

<WidgetLayout
	name={i18n(I18nKey.siteStats)}
	id="site-stats"
	class={className}
	style={style}
>
	<div class="flex flex-col gap-1">
		{
			stats.map((stat) => (
				<div class="px-2 py-2">
					<div class="flex items-center justify-between">
						<div class="flex items-center gap-2.5 flex-1 min-w-0">
							<div class="text-[var(--primary)] text-xl shrink-0">
								<Icon name={stat.icon} />
							</div>
							<span class="text-neutral-700 dark:text-neutral-300 font-medium text-sm break-words leading-tight">
								{stat.label}
							</span>
						</div>
						<div class="flex items-center ml-3 shrink-0">
							<span
								class="text-base font-bold text-neutral-900 dark:text-neutral-100"
								data-stat-id={stat.id}
							>
								{stat.formatted ? formatNumber(stat.value) : stat.value}
							</span>
							{stat.suffix && (
								<span class="text-sm text-neutral-500 dark:text-neutral-400 ml-1">
									{stat.suffix}
								</span>
							)}
						</div>
					</div>
					{stat.id === "last-update" && (
						<div class="mt-2 ml-8" data-site-stats-dropdown>
							<button
								class="group flex justify-between items-center py-2 pl-3 pr-1 rounded-lg gap-4 w-full text-left hover:bg-[var(--btn-plain-bg-hover)] active:bg-[var(--btn-plain-bg-active)] transition"
								type="button"
								data-site-stats-dropdown-trigger
								aria-expanded="false"
							>
								<div class="text-xs font-medium text-neutral-600 dark:text-neutral-300">活动来源详情</div>
								<Icon
									name="material-symbols:keyboard-arrow-down-rounded"
									class="transition text-[1.25rem] text-[var(--primary)] site-stats-dropdown-arrow duration-200"
								/>
							</button>
							<div class="site-stats-submenu" data-site-stats-submenu>
								<div class="mt-1 flex flex-col gap-1.5">
									{activityItems.map((item) => (
										<div class="rounded-lg px-2 py-1.5 hover:bg-[var(--btn-plain-bg-hover)] transition">
											<div class="text-[11px] text-neutral-500 dark:text-neutral-400">{item.label}</div>
											{item.url ? (
												<a href={item.url} class="block text-sm font-medium text-neutral-800 dark:text-neutral-200 truncate hover:text-[var(--primary)]">
													{item.title}
												</a>
											) : (
												<span class="block text-sm font-medium text-neutral-800 dark:text-neutral-200 truncate">{item.title}</span>
											)}
											<div class="text-[11px] text-neutral-500 dark:text-neutral-400">
												{item.date ? new Date(item.date).toLocaleDateString("zh-CN") : "-"}
											</div>
										</div>
									))}
								</div>
							</div>
						</div>
					)}
				</div>
			))
		}
	</div>
</WidgetLayout>

<script is:inline define:vars={{ siteStartDate, lastActivityDate }}>
	function updateDynamicStats() {
		const now = new Date();

		const startDate = new Date(siteStartDate);
		const runDays = Math.ceil(Math.abs(now.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));
		document.querySelectorAll('[data-stat-id="running-days"]').forEach((element) => {
			element.textContent = runDays.toString();
		});

		if (!lastActivityDate) return;
		const elapsedMs = Math.abs(now.getTime() - new Date(lastActivityDate).getTime());
		const days = Math.floor(elapsedMs / (1000 * 60 * 60 * 24));

		document.querySelectorAll('[data-stat-id="last-update"]').forEach((element) => {
			if (days < 16) {
				const hours = Math.floor((elapsedMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
				const minutes = Math.floor((elapsedMs % (1000 * 60 * 60)) / (1000 * 60));
				const seconds = Math.floor((elapsedMs % (1000 * 60)) / 1000);
				element.textContent = `${days}天 ${hours}时 ${minutes}分 ${seconds}秒`;
			} else {
				element.textContent = `${days} 天前`;
			}
		});
	}

	updateDynamicStats();
	setInterval(updateDynamicStats, 1000);
</script>


<style>
	.site-stats-submenu {
		@apply max-h-0 overflow-hidden transition-all duration-300 ease-in-out;
	}

	[data-site-stats-dropdown][data-expanded="true"] .site-stats-submenu {
		@apply max-h-96;
	}

	[data-site-stats-dropdown][data-expanded="true"] .site-stats-dropdown-arrow {
		@apply rotate-180;
	}
</style>

<script>
	document.addEventListener("DOMContentLoaded", () => {
		const dropdowns = document.querySelectorAll("[data-site-stats-dropdown]");

		dropdowns.forEach((dropdown) => {
			const trigger = dropdown.querySelector("[data-site-stats-dropdown-trigger]");
			if (!trigger) return;

			trigger.addEventListener("click", () => {
				const isExpanded = dropdown.getAttribute("data-expanded") === "true";
				const nextState = (!isExpanded).toString();
				dropdown.setAttribute("data-expanded", nextState);
				trigger.setAttribute("aria-expanded", nextState);
			});
		});
	});
</script>
